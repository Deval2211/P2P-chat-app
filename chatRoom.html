<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Multi-Peer P2P Chat</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #roomHeader {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    #roomCode {
      font-weight: bold;
      user-select: all;
      width: 100px;
    }
    #chat {
      height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
    }
    input, button {
      margin-top: 10px;
      width: 100%;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div id="roomHeader">
    <div>You: <span id="youName"></span></div>
    <div>Room Code:</div>
    <input id="roomCode" readonly />
    <button id="copyBtn">Copy</button>
  </div>

  <div id="chat"></div>
  <input id="message" placeholder="Type a message">
  <button onclick="sendMessage()">Send</button>

  <script>
    // Parse URL params
    const params    = new URLSearchParams(window.location.search);
    const localName = params.get('name') || '';
    const localRoom = params.get('room') || 'global';
    if (!localName) {
      alert('Missing name.');
      window.location.href = 'index.html';
    }

    // Show name and room code
    document.getElementById('youName').innerText    = localName;
    const roomCodeInput = document.getElementById('roomCode');
    roomCodeInput.value = localRoom;

    // Copy button
    document.getElementById('copyBtn').onclick = async () => {
      try {
        await navigator.clipboard.writeText(localRoom);
        document.getElementById('copyBtn').innerText = 'Copied!';
        setTimeout(() => document.getElementById('copyBtn').innerText = 'Copy', 1000);
      } catch (e) {
        console.error('Copy failed', e);
      }
    };

    // WebSocket + WebRTC logic (unchanged except for roomHeader above)
    const ws        = new WebSocket("ws://15.206.63.64:8765");
    let localId;
    const peers     = {};
    const peerNames = {};
    const chatDiv   = document.getElementById("chat");
    const msgInput  = document.getElementById("message");

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: "join", name: localName, room: localRoom }));
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);

      if (msg.type === "id") {
        localId = msg.id;
        msg.peers.forEach(p => {
          peerNames[p.id] = p.name;
          initPeer(p.id, true);
        });

      } else if (msg.type === "peer-connected") {
        peerNames[msg.id] = msg.name;
        initPeer(msg.id, false);
        appendSystem(`${msg.name} joined.`);

      } else if (msg.type === "signal") {
        await handleSignal(msg);

      } else if (msg.type === "peer-disconnected") {
        const name = peerNames[msg.id] || msg.id;
        teardownPeer(msg.id);
        appendSystem(`${name} left.`);
      }
    };

    function initPeer(peerId, isInitiator) {
      if (peers[peerId]) return;
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });
      peers[peerId] = { pc, channel: null };

      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          ws.send(JSON.stringify({
            type: "signal", from: localId, to: peerId, candidate
          }));
        }
      };

      pc.ondatachannel = ({ channel }) => setupChannel(peerId, channel);

      if (isInitiator) {
        const channel = pc.createDataChannel("chat");
        setupChannel(peerId, channel);
        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            ws.send(JSON.stringify({
              type: "signal", from: localId, to: peerId, sdp: pc.localDescription
            }));
          })
          .catch(console.error);
      }
    }

    async function handleSignal({ from, sdp, candidate }) {
      if (!peers[from]) initPeer(from, false);
      const { pc } = peers[from];

      if (sdp) {
        await pc.setRemoteDescription(sdp);
        if (sdp.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({
            type: "signal", from: localId, to: from, sdp: pc.localDescription
          }));
        }
      }
      if (candidate) {
        await pc.addIceCandidate(candidate).catch(console.warn);
      }
    }

    function setupChannel(peerId, channel) {
      peers[peerId].channel = channel;
      channel.onopen    = () => console.log(`[DC] open ${peerId}`);
      channel.onerror   = console.error;
      channel.onmessage = ({ data }) => {
        const name = peerNames[peerId] || peerId;
        appendMsg(name, data);
      };
    }

    function sendMessage() {
      const text = msgInput.value.trim();
      if (!text) return;
      appendMsg(localName, text);

      Object.values(peers).forEach(({ channel }) => {
        if (channel?.readyState === "open") channel.send(text);
      });
      msgInput.value = "";
    }

    function appendMsg(user, text) {
      chatDiv.innerHTML += `<div><b>${user}:</b> ${text}</div>`;
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    function appendSystem(text) {
      chatDiv.innerHTML += `<div style="color:#888;"><i>${text}</i></div>`;
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    function teardownPeer(peerId) {
      const entry = peers[peerId];
      if (!entry) return;
      entry.channel?.close();
      entry.pc.close();
      delete peers[peerId];
      delete peerNames[peerId];
    }
  </script>
</body>
</html>
