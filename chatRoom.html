<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P Chat Room</title>
  <link rel="stylesheet" href="ui.css">
</head>
<body class="chat-body">
  <div class="connection-status" id="connectionStatus">Connecting...</div>
  
  <div class="chat-container">
    <div class="header">
      <div class="header-left">
        <div class="chat-logo">üí¨ P2P Chat</div>
        <div class="user-info">
          <div class="user-avatar" id="userAvatar"></div>
          <span id="userName"></span>
        </div>
      </div>
      
      <div class="room-info">
        <span>Room:</span>
        <span class="room-code" id="roomCode"></span>
        <button class="copy-btn" id="copyBtn">Copy</button>
      </div>

        <a id="backBtn" class="chat-back-btn">‚Üê Back</a>      
    </div>

    <div class="chat-area">
      <div class="messages" id="messages">
        <div class="system-message" id="welcomeMsg">Welcome to the chat! Messages will appear here.</div>
      </div>
      
      <div class="typing-indicator" id="typingIndicator">Someone is typing...</div>
      
      <button id="scrollToBottomBtn" class="scroll-to-bottom-btn" onclick="scrollToBottom()" style="display: none;">
        <span class="scroll-icon">‚Üì</span>
        <span class="scroll-text">New Messages</span>
      </button>
      
      <div class="input-area">
        <textarea 
          id="messageInput" 
          class="message-input" 
          placeholder="Type your message..."
          rows="1"
        ></textarea>
        <button id="sendBtn" class="send-btn" onclick="sendMessage()">
          Send
        </button>
      </div>
    </div>
  </div>

  <script>
    // Parse URL params
    const params = new URLSearchParams(window.location.search);
    const localName = params.get('name') || '';
    const localRoom = params.get('room') || 'global';
    document.getElementById('backBtn').href = `lobby.html?name=${encodeURIComponent(localName)}`;
    
    if (!localName) {
      alert('Missing name.');
      window.location.href = 'index.html';
    }

    // Set user info
    document.getElementById('userName').innerText = localName;
    document.getElementById('userAvatar').innerText = localName.charAt(0).toUpperCase();
    document.getElementById('roomCode').innerText = localRoom;

    // Copy button functionality
    document.getElementById('copyBtn').onclick = async () => {
      try {
        await navigator.clipboard.writeText(localRoom);
        const btn = document.getElementById('copyBtn');
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      } catch (e) {
        console.error('Copy failed', e);
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      const welcomeMsg = document.getElementById('welcomeMsg');
      if (welcomeMsg) {
        setTimeout(() => {
          welcomeMsg.style.opacity = '0';
          welcomeMsg.style.transition = 'opacity 0.4s';
          setTimeout(() => {
            if (welcomeMsg.parentNode) {
              welcomeMsg.parentNode.removeChild(welcomeMsg);
            }
          }, 400);
        }, 4000);
      }
    });

    // Auto-resize textarea
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });

    // Handle Enter key (Shift+Enter for new line)
    messageInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // --- WebSocket + WebRTC logic ---
    const ws = new WebSocket("ws://13.234.42.145:8765");
    let localId;
    const peers = {};
    const peerNames = {};
    const candidateQueues = {};
    const messagesDiv = document.getElementById("messages");
    const connectionStatus = document.getElementById("connectionStatus");

    ws.onopen = () => {
      connectionStatus.textContent = "Connected";
      connectionStatus.className = "connection-status status-connected";
      console.log("[WS] Connected");
      ws.send(JSON.stringify({ type: "join", name: localName, room: localRoom }));
    };

    ws.onclose = () => {
      connectionStatus.textContent = "Disconnected";
      connectionStatus.className = "connection-status status-disconnected";
      console.log("[WS] Disconnected");
    };

    ws.onerror = (err) => {
      connectionStatus.textContent = "Connection Error";
      connectionStatus.className = "connection-status status-disconnected";
      console.error("[WS] Error", err);
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);
      console.log("[WS] Message", msg);

      if (msg.type === "id") {
        localId = msg.id;
        msg.peers.forEach(p => {
          peerNames[p.id] = p.name;
          initPeer(p.id, true);
        });

      } else if (msg.type === "peer-connected") {
        peerNames[msg.id] = msg.name;
        initPeer(msg.id, false);
        appendSystem(`${msg.name} joined the chat`);

      } else if (msg.type === "signal") {
        await handleSignal(msg);

      } else if (msg.type === "peer-disconnected") {
        const name = peerNames[msg.id] || msg.id;
        teardownPeer(msg.id);
        appendSystem(`${name} left the chat`);
      }
    };

    function queueCandidate(from, cand) {
      (candidateQueues[from] ||= []).push(cand);
    }
    async function flushQueued(from) {
      const q = candidateQueues[from] || [];
      while (q.length) {
        const c = q.shift();
        try { await peers[from].pc.addIceCandidate(c); }
        catch (e) { console.warn('[ICE] queued add failed', e); }
      }
    }

    function initPeer(peerId, isInitiator) {
      if (peers[peerId]) return;

      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      peers[peerId] = { pc, channel: null };

      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          console.log("[ICE] local candidate ->", peerId, candidate);
          ws.send(JSON.stringify({
            type: "signal", from: localId, to: peerId, candidate: candidate.toJSON()
          }));
        }
      };

      pc.oniceconnectionstatechange = () =>
        console.log(`[ICE] ${peerId} ->`, pc.iceConnectionState);
      pc.onconnectionstatechange = () =>
        console.log(`[PC] ${peerId} ->`, pc.connectionState);

      pc.ondatachannel = ({ channel }) => setupChannel(peerId, channel);

      if (isInitiator) {
        const channel = pc.createDataChannel("chat");
        setupChannel(peerId, channel);
        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            console.log("[SDP] sending offer ->", peerId);
            ws.send(JSON.stringify({
              type: "signal", from: localId, to: peerId, sdp: pc.localDescription
            }));
          })
          .catch(console.error);
      }
    }

    async function handleSignal({ from, sdp, candidate }) {
      if (!peers[from]) initPeer(from, false);
      const { pc } = peers[from];

      if (sdp) {
        try {
          await pc.setRemoteDescription(sdp);
          console.log("[SDP] setRemoteDescription from", from, sdp.type);
          if (sdp.type === "offer") {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({
              type: "signal", from: localId, to: from, sdp: pc.localDescription
            }));
          }
          await flushQueued(from);
        } catch (e) {
          console.error("[SDP] error", e);
        }
      }
      if (candidate) {
        if (pc.remoteDescription) {
          try {
            await pc.addIceCandidate(candidate);
            console.log("[ICE] addCandidate from", from);
          } catch (e) { console.warn("[ICE] error", e); }
        } else {
          queueCandidate(from, candidate);
          console.log("[ICE] queued candidate from", from);
        }
      }
    }

    function setupChannel(peerId, channel) {
      peers[peerId].channel = channel;
      channel.onopen = () => {
        console.log(`[DC] open ${peerId}`);
        appendSystem(`${peerNames[peerId] || peerId} is online`);
      };
      channel.onclose = () => console.log(`[DC] close ${peerId}`);
      channel.onerror = (e) => console.error(`[DC] error ${peerId}`, e);
      channel.onmessage = ({ data }) => {
        const name = peerNames[peerId] || peerId;
        appendMessage(name, data, false);
      };
    }

    function sendMessage() {
      const text = messageInput.value.trim();
      if (!text) return;
      appendMessage(localName, text, true);

      Object.values(peers).forEach(({ channel }) => {
        if (channel?.readyState === "open") channel.send(text);
      });

      messageInput.value = "";
      messageInput.style.height = 'auto';
    }

    function isScrolledToBottom(element) {
      return element.scrollHeight - element.clientHeight <= element.scrollTop + 1;
    }
    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function appendMessage(user, text, isOwn) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isOwn ? 'own' : ''}`;
      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.textContent = user.charAt(0).toUpperCase();
      const content = document.createElement('div');
      content.className = 'message-content';
      const sender = document.createElement('div');
      sender.className = 'message-sender';
      sender.textContent = user;
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = text;
      content.appendChild(sender);
      content.appendChild(bubble);
      messageDiv.appendChild(avatar);
      messageDiv.appendChild(content);
      messagesDiv.appendChild(messageDiv);
      scrollToBottom();
    }

    function appendSystem(text) {
      const systemDiv = document.createElement('div');
      systemDiv.className = 'system-message';
      systemDiv.textContent = text;
      messagesDiv.appendChild(systemDiv);
      scrollToBottom();
      // Remove system message after 4 seconds
      setTimeout(() => {
        systemDiv.style.opacity = '0';
        systemDiv.style.transition = 'opacity 0.4s';
        setTimeout(() => {
          if (systemDiv.parentNode) {
            systemDiv.parentNode.removeChild(systemDiv);
          }
        }, 400);
      }, 4000);
    }

    function teardownPeer(peerId) {
      const entry = peers[peerId];
      if (!entry) return;
      entry.channel?.close();
      entry.pc.close();
      delete peers[peerId];
      delete peerNames[peerId];
    }

    const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
    function updateScrollButton() {
      const isAtBottom = isScrolledToBottom(messagesDiv);
      const hasScrollableContent = messagesDiv.scrollHeight > messagesDiv.clientHeight;
      if (!isAtBottom && hasScrollableContent) {
        scrollToBottomBtn.style.display = 'flex';
        scrollToBottomBtn.style.opacity = '1';
      } else {
        scrollToBottomBtn.style.opacity = '0';
        setTimeout(() => {
          if (scrollToBottomBtn.style.opacity === '0') {
            scrollToBottomBtn.style.display = 'none';
          }
        }, 300);
      }
    }
    messagesDiv.addEventListener('scroll', updateScrollButton);
    window.addEventListener('resize', updateScrollButton);
    setTimeout(updateScrollButton, 500);

    window.addEventListener('load', () => messageInput.focus());
  </script>
</body>
</html>
