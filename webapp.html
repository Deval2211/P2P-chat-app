<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Multi-Peer P2P Chat</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #chat { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    input, button { margin-top: 10px; width: 100%; box-sizing: border-box; }
  </style>
</head>
<body>
  <h2>Room “main” Chat</h2>
  <div id="chat"></div>
  <input id="message" placeholder="Type a message">
  <button onclick="sendMessage()">Send</button>

  <script>
    const ws = new WebSocket("ws://65.1.100.167:8765");
    let localId;
    const peers = {}; // peerId -> { pc: RTCPeerConnection, channel: RTCDataChannel }

    const chatDiv = document.getElementById("chat");
    const msgInput = document.getElementById("message");

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);

      if (msg.type === "id") {
        // Our assigned ID + initial peer list
        localId = msg.id;
        console.log("[WS] My ID:", localId);
        // Kick-off connections to each existing peer
        msg.peers.forEach(pid => createPeer(pid, true));

      } else if (msg.type === "peer-connected") {
        console.log("[WS] Peer joined:", msg.id);
        // A newcomer: wait for their offer
        createPeer(msg.id, false);

      } else if (msg.type === "signal") {
        // SDP or ICE candidate relay
        await handleSignal(msg);

      } else if (msg.type === "peer-disconnected") {
        cleanupPeer(msg.id);
      }
    };

    function createPeer(peerId, isInitiator) {
      if (peers[peerId]) return;  // only once

      console.log(`[PEER] init ${peerId}, initiator=${isInitiator}`);
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });
      peers[peerId] = { pc, channel: null };

      // Relay ICE candidates as soon as we find them
      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          ws.send(JSON.stringify({
            type: "signal",
            from: localId,
            to: peerId,
            candidate
          }));
        }
      };

      // Non-initiator: wait for datachannel to be created by remote
      pc.ondatachannel = ({ channel }) => setupChannel(peerId, channel);

      if (isInitiator) {
        // Initiator: open our data channel, then make an SDP offer
        const channel = pc.createDataChannel("chat");
        setupChannel(peerId, channel);

        pc.createOffer()
          .then(offer => pc.setLocalDescription(offer))
          .then(() => {
            ws.send(JSON.stringify({
              type: "signal",
              from: localId,
              to: peerId,
              sdp: pc.localDescription
            }));
          })
          .catch(console.error);
      }
    }

    async function handleSignal({ from, sdp, candidate }) {
      // Ensure we have a PeerConnection
      if (!peers[from]) createPeer(from, false);
      const { pc } = peers[from];

      if (sdp) {
        // Modern Chrome/Firefox accept the raw RTCSessionDescriptionInit object
        await pc.setRemoteDescription(sdp);
        if (sdp.type === "offer") {
          // Respond with an answer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({
            type: "signal",
            from: localId,
            to: from,
            sdp: pc.localDescription
          }));
        }
      }

      if (candidate) {
        // Modern API lets you pass the plain candidate object
        try {
          await pc.addIceCandidate(candidate);
        } catch (err) {
          console.warn("ICE candidate error:", err);
        }
      }
    }

    function setupChannel(peerId, channel) {
      peers[peerId].channel = channel;

      channel.onopen = () => console.log(`[DC] open ${peerId}`);
      channel.onmessage = ({ data }) => appendMsg(peerId, data);
      channel.onerror   = console.error;
    }

    function sendMessage() {
      const text = msgInput.value.trim();
      if (!text) return;

      appendMsg("You", text);
      Object.values(peers).forEach(({ channel }) => {
        if (channel && channel.readyState === "open") {
          channel.send(text);
        }
      });
      msgInput.value = "";
    }

    function appendMsg(user, text) {
      chatDiv.innerHTML += `<div><b>${user}:</b> ${text}</div>`;
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    function cleanupPeer(peerId) {
      const entry = peers[peerId];
      if (!entry) return;

      entry.channel?.close();
      entry.pc.close();
      delete peers[peerId];
      appendMsg("System", `Peer ${peerId} left`);
    }
  </script>
</body>
</html>
