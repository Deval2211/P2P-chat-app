<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Multi-Peer P2P Chat</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #chat { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    input, button { margin-top: 10px; width: 100%; box-sizing: border-box; }
  </style>
</head>
<body>
  <h2>Room “main” Chat</h2>
  <div id="chat"></div>
  <input id="message" placeholder="Type a message">
  <button onclick="sendMessage()">Send</button>

  <script>
    // Utility: parse ?name=… from URL
    function getQueryParam(name) {
      return new URLSearchParams(window.location.search).get(name) || '';
    }

    const localName = getQueryParam('name');
    if (!localName) {
      alert('No name provided. Redirecting back.');
      window.location.href = 'index.html';
    }

    const ws      = new WebSocket("ws://65.1.100.167:8765");
    let localId;
    const peers     = {}; // peerId -> { pc, channel }
    const peerNames = {}; // peerId -> displayName

    const chatDiv = document.getElementById("chat");
    const msgInput = document.getElementById("message");

    ws.onopen = () => {
      console.log('[WS] connected, waiting for ID…');
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);

      if (msg.type === "id") {
        // Server assigned us an ID + peers list with names
        localId = msg.id;
        msg.peers.forEach(p => {
          peerNames[p.id] = p.name;
          createPeer(p.id, true);
        });

        // Now tell server our chosen name
        ws.send(JSON.stringify({
          type: "set-name",
          name: localName
        }));

      } else if (msg.type === "peer-connected") {
        // A new peer joined: store their name, then init connection
        peerNames[msg.id] = msg.name;
        createPeer(msg.id, false);

        appendSystem(`${msg.name} joined the chat.`);
      }

      else if (msg.type === "signal") {
        await handleSignal(msg);

      } else if (msg.type === "peer-disconnected") {
        // Clean up
        const name = peerNames[msg.id] || msg.id;
        cleanupPeer(msg.id);
        appendSystem(`${name} left the chat.`);
      }
    };

    function createPeer(peerId, isInitiator) {
      if (peers[peerId]) return;
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });
      peers[peerId] = { pc, channel: null };

      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          ws.send(JSON.stringify({
            type: "signal",
            from: localId,
            to:   peerId,
            candidate
          }));
        }
      };

      pc.ondatachannel = ({ channel }) => setupChannel(peerId, channel);

      if (isInitiator) {
        const channel = pc.createDataChannel("chat");
        setupChannel(peerId, channel);

        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            ws.send(JSON.stringify({
              type: "signal",
              from: localId,
              to:   peerId,
              sdp:  pc.localDescription
            }));
          })
          .catch(console.error);
      }
    }

    async function handleSignal({ from, sdp, candidate }) {
      if (!peers[from]) createPeer(from, false);
      const { pc } = peers[from];

      if (sdp) {
        await pc.setRemoteDescription(sdp);
        if (sdp.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({
            type: "signal",
            from: localId,
            to:   from,
            sdp:  pc.localDescription
          }));
        }
      }
      if (candidate) {
        await pc.addIceCandidate(candidate).catch(console.warn);
      }
    }

    function setupChannel(peerId, channel) {
      peers[peerId].channel = channel;
      channel.onopen    = () => console.log(`[DC] open ${peerId}`);
      channel.onerror   = console.error;
      channel.onmessage = ({ data }) => {
        const name = peerNames[peerId] || peerId;
        appendMsg(name, data);
      };
    }

    function sendMessage() {
      const text = msgInput.value.trim();
      if (!text) return;
      appendMsg(localName, text);

      Object.values(peers).forEach(({ channel }) => {
        if (channel && channel.readyState === "open") {
          channel.send(text);
        }
      });
      msgInput.value = "";
    }

    function appendMsg(user, text) {
      chatDiv.innerHTML += `<div><b>${user}:</b> ${text}</div>`;
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    function appendSystem(text) {
      chatDiv.innerHTML += `<div style="color: #888;"><i>${text}</i></div>`;
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    function cleanupPeer(peerId) {
      const entry = peers[peerId];
      if (!entry) return;
      entry.channel?.close();
      entry.pc.close();
      delete peers[peerId];
      delete peerNames[peerId];
    }
  </script>
</body>
</html>
