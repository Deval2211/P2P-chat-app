<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P Chat Room</title>
  <link rel="stylesheet" href="ui.css">
</head>
<body class="chat-body">
  <div class="connection-status" id="connectionStatus">Connecting...</div>
  
  <div class="chat-container">
    <div class="header">
      <div class="header-left">
        <div class="chat-logo">üí¨ P2P Chat</div>
        <div class="user-info">
          <div class="user-avatar" id="userAvatar"></div>
          <span id="userName"></span>
        </div>
      </div>
      
      <div class="room-info">
        <span>Room:</span>
        <span class="room-code" id="roomCode"></span>
        <button class="copy-btn" id="copyBtn">Copy</button>
      </div>
      
      <a href="lobby.html" class="chat-back-btn">‚Üê Back</a>
    </div>

    <div class="chat-area">
      <div class="messages" id="messages">
        <div class="system-message">Welcome to the chat! Messages will appear here.</div>
      </div>
      
      <div class="typing-indicator" id="typingIndicator">Someone is typing...</div>
      
      <button id="scrollToBottomBtn" class="scroll-to-bottom-btn" onclick="scrollToBottom()" style="display: none;">
        <span class="scroll-icon">‚Üì</span>
        <span class="scroll-text">New Messages</span>
      </button>
      
      <div class="input-area">
        <textarea 
          id="messageInput" 
          class="message-input" 
          placeholder="Type your message..."
          rows="1"
        ></textarea>
        <button id="sendBtn" class="send-btn" onclick="sendMessage()">
          Send
        </button>
      </div>
    </div>
  </div>

  <script>
    // Parse URL params
    const params = new URLSearchParams(window.location.search);
    const localName = params.get('name') || '';
    const localRoom = params.get('room') || 'global';
    
    if (!localName) {
      alert('Missing name.');
      window.location.href = 'index.html';
    }

    // Set user info
    document.getElementById('userName').innerText = localName;
    document.getElementById('userAvatar').innerText = localName.charAt(0).toUpperCase();
    document.getElementById('roomCode').innerText = localRoom;

    // Copy button functionality
    document.getElementById('copyBtn').onclick = async () => {
      try {
        await navigator.clipboard.writeText(localRoom);
        const btn = document.getElementById('copyBtn');
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      } catch (e) {
        console.error('Copy failed', e);
      }
    };

    // Auto-resize textarea
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });

    // Handle Enter key (Shift+Enter for new line)
    messageInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // WebSocket + WebRTC logic
    const ws = new WebSocket("ws://15.206.63.64:8765");
    let localId;
    const peers = {};
    const peerNames = {};
    const messagesDiv = document.getElementById("messages");
    const connectionStatus = document.getElementById("connectionStatus");

    ws.onopen = () => {
      connectionStatus.textContent = "Connected";
      connectionStatus.className = "connection-status status-connected";
      ws.send(JSON.stringify({ type: "join", name: localName, room: localRoom }));
    };

    ws.onclose = () => {
      connectionStatus.textContent = "Disconnected";
      connectionStatus.className = "connection-status status-disconnected";
    };

    ws.onerror = () => {
      connectionStatus.textContent = "Connection Error";
      connectionStatus.className = "connection-status status-disconnected";
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);

      if (msg.type === "id") {
        localId = msg.id;
        msg.peers.forEach(p => {
          peerNames[p.id] = p.name;
          initPeer(p.id, true);
        });

      } else if (msg.type === "peer-connected") {
        peerNames[msg.id] = msg.name;
        initPeer(msg.id, false);
        appendSystem(`${msg.name} joined the chat`);

      } else if (msg.type === "signal") {
        await handleSignal(msg);

      } else if (msg.type === "peer-disconnected") {
        const name = peerNames[msg.id] || msg.id;
        teardownPeer(msg.id);
        appendSystem(`${name} left the chat`);
      }
    };

    function initPeer(peerId, isInitiator) {
      if (peers[peerId]) return;
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });
      peers[peerId] = { pc, channel: null };

      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          ws.send(JSON.stringify({
            type: "signal", from: localId, to: peerId, candidate
          }));
        }
      };

      pc.ondatachannel = ({ channel }) => setupChannel(peerId, channel);

      if (isInitiator) {
        const channel = pc.createDataChannel("chat");
        setupChannel(peerId, channel);
        pc.createOffer()
          .then(o => pc.setLocalDescription(o))
          .then(() => {
            ws.send(JSON.stringify({
              type: "signal", from: localId, to: peerId, sdp: pc.localDescription
            }));
          })
          .catch(console.error);
      }
    }

    async function handleSignal({ from, sdp, candidate }) {
      if (!peers[from]) initPeer(from, false);
      const { pc } = peers[from];

      if (sdp) {
        await pc.setRemoteDescription(sdp);
        if (sdp.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({
            type: "signal", from: localId, to: from, sdp: pc.localDescription
          }));
        }
      }
      if (candidate) {
        await pc.addIceCandidate(candidate).catch(console.warn);
      }
    }

    function setupChannel(peerId, channel) {
      peers[peerId].channel = channel;
      channel.onopen = () => console.log(`[DC] open ${peerId}`);
      channel.onerror = console.error;
      channel.onmessage = ({ data }) => {
        const name = peerNames[peerId] || peerId;
        appendMessage(name, data, false);
      };
    }

    function sendMessage() {
      const text = messageInput.value.trim();
      if (!text) return;
      
      appendMessage(localName, text, true);

      Object.values(peers).forEach(({ channel }) => {
        if (channel?.readyState === "open") channel.send(text);
      });
      
      messageInput.value = "";
      messageInput.style.height = 'auto';
    }

    // Smart auto-scroll functionality
    function isScrolledToBottom(element) {
      return element.scrollHeight - element.clientHeight <= element.scrollTop + 1;
    }

    function scrollToBottom() {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function appendMessage(user, text, isOwn) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isOwn ? 'own' : ''}`;
      
      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.textContent = user.charAt(0).toUpperCase();
      
      const content = document.createElement('div');
      content.className = 'message-content';
      
      const sender = document.createElement('div');
      sender.className = 'message-sender';
      sender.textContent = user;
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = text;
      
      content.appendChild(sender);
      content.appendChild(bubble);
      messageDiv.appendChild(avatar);
      messageDiv.appendChild(content);
      
      messagesDiv.appendChild(messageDiv);
      
      // Always scroll to bottom for new messages
      scrollToBottom();
    }

    function appendSystem(text) {
      const systemDiv = document.createElement('div');
      systemDiv.className = 'system-message';
      systemDiv.textContent = text;
      messagesDiv.appendChild(systemDiv);
      
      // Always scroll to bottom for system messages
      scrollToBottom();
    }

    function teardownPeer(peerId) {
      const entry = peers[peerId];
      if (!entry) return;
      entry.channel?.close();
      entry.pc.close();
      delete peers[peerId];
      delete peerNames[peerId];
    }

    // Enhanced scroll to bottom button functionality
    const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
    
    function updateScrollButton() {
      const isAtBottom = isScrolledToBottom(messagesDiv);
      const hasScrollableContent = messagesDiv.scrollHeight > messagesDiv.clientHeight;
      
      if (!isAtBottom && hasScrollableContent) {
        scrollToBottomBtn.style.display = 'flex';
        scrollToBottomBtn.style.opacity = '1';
      } else {
        scrollToBottomBtn.style.opacity = '0';
        setTimeout(() => {
          if (scrollToBottomBtn.style.opacity === '0') {
            scrollToBottomBtn.style.display = 'none';
          }
        }, 300);
      }
    }
    
    messagesDiv.addEventListener('scroll', updateScrollButton);
    
    // Also check on window resize and when new messages are added
    window.addEventListener('resize', updateScrollButton);
    
    // Check after a short delay to ensure content is loaded
    setTimeout(updateScrollButton, 500);
    
    // Update scroll button after each message
    const originalAppendMessage = appendMessage;
    appendMessage = function(user, text, isOwn) {
      originalAppendMessage(user, text, isOwn);
      setTimeout(updateScrollButton, 100);
    };
    
    const originalAppendSystem = appendSystem;
    appendSystem = function(text) {
      originalAppendSystem(text);
      setTimeout(updateScrollButton, 100);
    };

    // Focus on input when page loads
    window.addEventListener('load', () => {
      messageInput.focus();
    });
  </script>
</body>
</html>
